## TLS Bootstrapping Worker Nodes

### Overview

TLS bootstrapping simplifies the process of managing certificates for worker nodes in a Kubernetes cluster. This method allows nodes to generate their own certificates and submit Certificate Signing Requests (CSRs) to the Kubernetes CA, which then signs and returns the certificates. This process reduces manual intervention, especially in large clusters.

### Requirements

1. **Certificates API**: Provides APIs for managing certificates.
2. **kube-apiserver**: Ensure bootstrap token-based authentication is enabled.
3. **kube-controller-manager**: Requires CA certificate and key for signing CSRs.

### Steps

#### Step 1: Create Bootstrap Token

1. Set an expiration date for the token:

   ```bash
   EXPIRATION=$(date -u --date "+7 days" +"%Y-%m-%dT%H:%M:%SZ")
   ```

2. Create a YAML file for the bootstrap token:

   ```bash
   cat > bootstrap-token-07401b.yaml <<EOF
   apiVersion: v1
   kind: Secret
   metadata:
     name: bootstrap-token-07401b
     namespace: kube-system
   type: bootstrap.kubernetes.io/token
   stringData:
     description: "The default bootstrap token generated by 'kubeadm init'."
     token-id: 07401b
     token-secret: f395accd246ae52d
     expiration: ${EXPIRATION}
     usage-bootstrap-authentication: "true"
     usage-bootstrap-signing: "true"
     auth-extra-groups: system:bootstrappers:worker
   EOF
   ```

3. Apply the token:
   ```bash
   kubectl create -f bootstrap-token-07401b.yaml --kubeconfig admin.kubeconfig
   ```

#### Step 2: Authorize Nodes to Create CSR

1. Create a ClusterRoleBinding:
   ```bash
   kubectl create clusterrolebinding create-csrs-for-bootstrapping \
     --clusterrole=system:node-bootstrapper \
     --group=system:bootstrappers \
     --kubeconfig admin.kubeconfig
   ```

#### Step 3: Authorize Nodes to Approve CSRs

1. Create a ClusterRoleBinding:
   ```bash
   kubectl create clusterrolebinding auto-approve-csrs-for-group \
     --clusterrole=system:certificates.k8s.io:certificatesigningrequests:nodeclient \
     --group=system:bootstrappers \
     --kubeconfig admin.kubeconfig
   ```

#### Step 4: Authorize Nodes to Auto Renew Certificates

1. Create a ClusterRoleBinding:
   ```bash
   kubectl create clusterrolebinding auto-approve-renewals-for-nodes \
     --clusterrole=system:certificates.k8s.io:certificatesigningrequests:selfnodeclient \
     --group=system:nodes \
     --kubeconfig admin.kubeconfig
   ```

#### Step 5: Configure Worker Node Binaries

1. Download and install worker binaries:

   ```bash
   KUBE_VERSION=$(curl -L -s https://dl.k8s.io/release/stable.txt)
   wget -q --show-progress --https-only --timestamping \
     https://dl.k8s.io/release/${KUBE_VERSION}/bin/linux/amd64/kube-proxy \
     https://dl.k8s.io/release/${KUBE_VERSION}/bin/linux/amd64/kubelet
   ```

2. Create installation directories:

   ```bash
   sudo mkdir -p /var/lib/kubelet/pki /var/lib/kube-proxy /var/lib/kubernetes/pki /var/run/kubernetes
   ```

3. Install the binaries:

   ```bash
   chmod +x kube-proxy kubelet
   sudo mv kube-proxy kubelet /usr/local/bin/
   ```

4. Move and secure certificates:
   ```bash
   sudo mv ca.crt kube-proxy.crt kube-proxy.key /var/lib/kubernetes/pki
   sudo chown root:root /var/lib/kubernetes/pki/*
   sudo chmod 600 /var/lib/kubernetes/pki/*
   ```

## Step 6: Configure Kubelet for TLS Bootstrap

To configure the second worker node (`node02`) for TLS bootstrapping using the generated token, follow these steps. Unlike `node01`, we don't have the certificates yet, so we'll create a bootstrap-kubeconfig file with the token information.

### Set Shell Variables

```bash
LOADBALANCER=$(dig +short loadbalancer)
POD_CIDR=10.244.0.0/16
SERVICE_CIDR=10.96.0.0/16
CLUSTER_DNS=$(echo $SERVICE_CIDR | awk 'BEGIN {FS="."} ; { printf("%s.%s.%s.10", $1, $2, $3) }')
```

### Create Bootstrap Kubeconfig

Option 1:

```bash
{
  sudo kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig \
    set-cluster bootstrap --server="https://${LOADBALANCER}:6443" --certificate-authority=/var/lib/kubernetes/pki/ca.crt

  sudo kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig \
    set-credentials kubelet-bootstrap --token=07401b.f395accd246ae52d

  sudo kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig \
    set-context bootstrap --user=kubelet-bootstrap --cluster=bootstrap

  sudo kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig \
    use-context bootstrap
}
```

Option 2:

```bash
cat <<EOF | sudo tee /var/lib/kubelet/bootstrap-kubeconfig
apiVersion: v1
clusters:
- cluster:
    certificate-authority: /var/lib/kubernetes/pki/ca.crt
    server: https://${LOADBALANCER}:6443
  name: bootstrap
contexts:
- context:
    cluster: bootstrap
    user: kubelet-bootstrap
  name: bootstrap
current-context: bootstrap
kind: Config
preferences: {}
users:
- name: kubelet-bootstrap
  user:
    token: 07401b.f395accd246ae52d
EOF
```

## Step 7: Create Kubelet Config File

Create the `kubelet-config.yaml` file:

```bash
cat <<EOF | sudo tee /var/lib/kubelet/kubelet-config.yaml
kind: KubeletConfiguration
apiVersion: kubelet.config.k8s.io/v1beta1
authentication:
  anonymous:
    enabled: false
  webhook:
    enabled: true
  x509:
    clientCAFile: /var/lib/kubernetes/pki/ca.crt
authorization:
  mode: Webhook
containerRuntimeEndpoint: unix:///var/run/containerd/containerd.sock
cgroupDriver: systemd
clusterDomain: "cluster.local"
clusterDNS:
  - ${CLUSTER_DNS}
registerNode: true
resolvConf: /run/systemd/resolve/resolv.conf
rotateCertificates: true
serverTLSBootstrap: true
EOF
```

## Step 8: Configure Kubelet Service

Create the `kubelet.service` systemd unit file:

```bash
cat <<EOF | sudo tee /etc/systemd/system/kubelet.service
[Unit]
Description=Kubernetes Kubelet
Documentation=https://github.com/kubernetes/kubernetes
After=containerd.service
Requires=containerd.service

[Service]
ExecStart=/usr/local/bin/kubelet \\
  --bootstrap-kubeconfig="/var/lib/kubelet/bootstrap-kubeconfig" \\
  --config=/var/lib/kubelet/kubelet-config.yaml \\
  --kubeconfig=/var/lib/kubelet/kubeconfig \\
  --cert-dir=/var/lib/kubelet/pki/ \\
  --node-ip=${PRIMARY_IP} \\
  --v=2
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF
```

## Step 9: Configure Kubernetes Proxy

Move the `kube-proxy.kubeconfig` file:

```bash
{
  sudo mv kube-proxy.kubeconfig /var/lib/kube-proxy/
  sudo chown root:root /var/lib/kube-proxy/kube-proxy.kubeconfig
  sudo chmod 600 /var/lib/kube-proxy/kube-proxy.kubeconfig
}
```

Create the `kube-proxy-config.yaml` file:

```bash
cat <<EOF | sudo tee /var/lib/kube-proxy/kube-proxy-config.yaml
kind: KubeProxyConfiguration
apiVersion: kubeproxy.config.k8s.io/v1alpha1
clientConnection:
  kubeconfig: /var/lib/kube-proxy/kube-proxy.kubeconfig
mode: iptables
clusterCIDR: ${POD_CIDR}
EOF
```

Create the `kube-proxy.service` systemd unit file:

```bash
cat <<EOF | sudo tee /etc/systemd/system/kube-proxy.service
[Unit]
Description=Kubernetes Kube Proxy
Documentation=https://github.com/kubernetes/kubernetes

[Service]
ExecStart=/usr/local/bin/kube-proxy \\
  --config=/var/lib/kube-proxy/kube-proxy-config.yaml
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF
```

## Step 10: Start Worker Services

On `node02`, run:

```bash
{
  sudo systemctl daemon-reload
  sudo systemctl enable kubelet kube-proxy
  sudo systemctl start kubelet kube-proxy
}
```

## Step 11: Approve Server CSR

On `controlplane01`, approve the pending kubelet-serving certificate:

```bash
kubectl get csr --kubeconfig admin.kubeconfig
```

Approve the pending certificate (replace `csr-7k8nh` with your CSR name):

```bash
kubectl certificate approve --kubeconfig admin.kubeconfig csr-7k8nh
```

## Verification

List the registered Kubernetes nodes from the control plane:

```bash
kubectl get nodes --kubeconfig admin.kubeconfig
```

Output should show nodes with `NotReady` status, which is expected at this stage.
